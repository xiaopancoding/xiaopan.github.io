package m1;

/*

    代码块，也是分为了两种， 一种就是  静态代码块，  还有一种就是非静态代码块
    代码块只能用static 修饰，

    静态代码块的作用：
        > 它是随着类的加载而执行，并且只执行一次
        > 一般用代码块来初始化，类中的一些属性， 也就是说 代码块的主要作用就是初始化
        > 静态代码块中也就是只能调用，静态的属性和静态的方法，不能调用非静态的， 因为， 静态的比非静态的先加载
        > 按照写代码块的先后顺序执行
    非静态代码块：
        > 随着对象的加载而执行， 每创建一个对象就执行一次
        > 也是用来初始化一些信息，不过这里初始化的信息为对象的信息
        > 非静态代码块比 构造器先执行
        > 显示赋值和代码块的先后顺序就要看你那个写在前面那个写在后面了
        > 非静态代码块 能调用静态的属性和方法， 也能调用非静态的属性和方法

 */

/*
    final关键字， 表示最终的

    可以修饰  类，  方法， 变量
    修饰类：
        > 可以理解这个类是最终的，也就是不能被继承，  已经到了最后了， 那就是没子类了， 那就是不能继承
    修饰方法：
        > 可以理解为这个方法是最终的， 那么就是这个方法不能被重写， 这个方法很完善了， 就不能重写
    修饰变量：
        > 表示这个变量不能重新赋值 ，用final 修饰的就是相当于变成了  常量了， 改变不了了

 */

/*

    abstract关键字  可以修饰类， 方法
    如果修饰类的话， 那么就表示这个类是 抽象类， 抽象类就是不能创建实例的， 也就是不能船舰对象， 但是构造器 属性， 方法还是有的，只是不能通过这个类进行实例化

    如果把方法用abstract修饰了的话， 那么他所属的类也必须要要用abstract修饰， 也就是说， 有抽象的方法他的类的就一定是抽象的， 但是反过来， 类的抽象的，不一定有抽象的方法


    如果抽象类中有抽象方法， 这个抽象方法是没有方法体的， 就只是简单的声明的，
    若子类重写了父类中所有的抽象方法后，此子类才可以实例化
    若子类没有重写父类中所有的抽象方法，则此子类也是一个抽象类

 */


public class daimakuai {



}


class Stude {

    private static int age;  // 这里体现了封装性
    private static String name;
    private int time;

    static {  // 这里就是静态的代码块， 只能调用静态的属性和方法
        age = 11;
        name = "Tom";  // 这里的属性都是大家公共的， 这个类的每个对象都有
        eat();
    }
    // 这里的是非静态的代码块
    {
        time = 12;  // 这里是调用非静态的属性， 也就是对象的属性

    }
    public static void eat() {
        System.out.println("吃饭");
    }


}