package m1;

public class T1 {

    public static void main(String[] args) {

        // static  这个关键字是 标记属性 方法  内部类， 代码块，  为静态的， 所谓静态的意思就是 就以属性为例，  如果定义了一个属性为静态的就说明这个属性是这个类公共的属性了
        // 如果创建了两个类的话， 那么这个属性是公共的， 也就是说  只要在一个类中修改了 这个属性， 那么在另一个类中， 这个属性值  也被修改了，
        //  那个最基本的例子来说明就是，  每个一个中国人  省份证号码， 电话号码， 等等都是不同的， 但是所有的人都国籍是一样的  都是中国，   所以国籍就是静态的属性， 只要这个国籍被修改， 那么所有人的国籍也就被修改了

        // 在生命周期去理解的话，  就是  静态属性  比  实例属性  先加载
        // 静态的是随着 类的加载而加载，二实例属性  是随着对象加载而加载
        // 也就是说 是先有静态属性 也叫 类属性， 后有实例属性， 也就是说  可以通过”类.静态属性“  调用， 而实例属性就不能这样调用

        // 还有静态方法  也是和  静态属性是一样  也是随着类的加载而加载， 但是 在静态方法中 通常调用，静态的属性，因为 如果要调用 实例属性， 但是还没有加载对象这时就还没有 实例属性， 调用不了
        // 所以  静态方法通常调用 静态的属性，
        // 还有要记得 静态属性和方法是  所以对象共有的 ，是共享，  也是能通过  ”类.静态方法“ 因为一定是先有 类， 之后有静态属性方法， 再有非静态属性和方法，
        // 静态的  是加载在 方法区的静态域中， 并不是加载在堆中

        Circle c1 = new Circle(2.3);
        Circle c2 = new Circle(2.4, "white", 2.0);
        System.out.println("颜色是否相等： " + c1.getColor().equals(c2.getColor()));  // 调用的是  重写之后的equals
        System.out.println(c2.toString());  // 这里也是调用之后重写的方法

//        T1 n = new T1();
//        n.op();
    }

    public void op() {
        int ans = 1;
        Integer a = ans;   // 这样的叫做自动装箱

        int b = a;  // 这样的叫做自动拆箱

        //  如果String 类型的想要转化为 基本数据类型的话，  就要用，
        String str = "11110";


        int num = 110;
        String str1 = num + "";  // 这两个方法是 把基本数据类型  转化为  String类型的常用 方法，  最直接的就是用第一个方法
        String str2 = String.valueOf(num);
        int nm = Integer.parseInt(str1);  // 这个是把String类型转化为  int 类型，因为有自动拆箱， 所以现在可以直接这样赋值

        System.out.println(nm + 1);

    }


}
